function [XrefHist,PplusHist,measDeltaHist] = ExtendedKF(EKFinputs)

%%%%%%%%%%% INPUTS: %%%%%%%%%%
% X0:           [6 x 1] Initial Total State we'll propagate with + STM
% P0:           [6 x 6] Initial uncertainty of initial condition
% Rkf:          [2 x 2] Assumed constant measurement noise (rho,rhoDot)
% yHist:        [Struct] History of measurements for all stations starting
%                   at t0+dt
% tVec:         [1 x n] time of whole simulation
% traj:         The truth trajectory, only here for debugging reasons
% stationECI:   [] History of all station states in ECI

%%%%%%%%%%% OUTPUTS: %%%%%%%%%
% xHist:         [6 x n] History of Total State Estimate


% --- Dynamically unpack the input struct for LKF

% Get all field names in the struct
fields = fieldnames(EKFinputs);

% Loop through each field and access its value dynamically
for i = 1:length(fields)
    % Get the field name
    fieldName = fields{i};
    
    % Access the value of the field using dynamic field referencing
    fieldValue = EKFinputs.(fieldName);
    
    eval([fieldName ' = fieldValue']);
    
end

% --- Measurements ---
% noisey measurements - these are from sensor
rangeMeas    = yHist.Range;
rangeDotMeas = yHist.RangeRate;

% Observed measurements (from sensor)
observedMeasAll = [rangeMeas, rangeDotMeas];

% --- Implement EKF Algorithm ---
% Naming convention
% Prev: Value from previous time step
% Minus: A Priori Value
% Plus: A Posteriori Value
%

% Set filter to loop 
for i = 1:length(tVec)
    
    if i == 1
        % set filter initial conditions
        XrefPrev = X0;
        pPrev = P0;
        timePrev = 0;
        
        % get initial phi 
        phi = reshape(XrefPrev(6+1:end), [6,6]);
        
        % initial reference position
        refPos = XrefPrev(1:3);
        refVel = XrefPrev(4:6);
        
        refTrajStates = [refPos', refVel'];
        
    else
        
        % --- Integrate Reference Traj ---
        % Set integrator options
        odeOptions = odeset('AbsTol',1e-12,'RelTol', 1e-12);
        
        % Integrate Trajectory
        [T, TrajNom] = ode45(@Dynamics.NumericJ2Prop, [timePrev,tVec(i)], XrefPrev, odeOptions, mu, J2, Re);
        
        % Extract the reference trajectory states
        refTrajStates = TrajNom(end,1:6);
        
        % reference traj position
        refPos = refTrajStates(1:3);
        refVel = refTrajStates(4:6);
        
        % Extract the Integrated STM - this maps previous time to current time
        phi = reshape(TrajNom(end,7:end), [6,6]);
        
    end
    
    % State Noise Compensation
    GammaQGamma = Dynamics.StateNoiseComp(tVec(i) - timePrev, Q);
    
    % --- Time Update ---
    pMinus = phi * pPrev * phi' + GammaQGamma;
    
    % --- Computed Measurements --- 
    % each station state
    for j = 1:3
        stationPosECI{i,j} = stationECI{i,j}(1:3);
        stationVelECI{i,j} = stationECI{i,j}(4:6);
    end
    
    % determine station visibility
    [visibilityMask, viewingAngles, ~, obTime] = Measurements.VisibilityMask(stationPosECI(i,:), refPos', 10, tVec(i), 10);
    
    if ~isempty(obTime)
        % observation was made by a station
        statNumOb = find(visibilityMask == 1);
        
        if length(statNumOb) > 1
            % if multiple obs then just take one (just for now)
            multiObs = length(statNumOb);
            warning('multiple observations at same time!')
        else
            % Nothing
            multiObs = 1; 
        end
        
        for q = 1:multiObs
            
        % Computed measurement from the station!
        rangeMeasComp     = refPos - cell2mat(stationPosECI(i,statNumOb(q)))';
        rangeNormComp     = norm(rangeMeasComp);
        rangeRateComp     = dot(rangeMeasComp, refVel - cell2mat(stationVelECI(i,statNumOb(q)))') / rangeNormComp;
        
        % stack computed measurements
        computedMeas = [rangeNormComp; rangeRateComp];
        
        % stack observed measurements
        observedMeas = rmmissing(observedMeasAll(i,:));
        
        % Measurement delta: Observed - Computed
        if isempty(observedMeas)
            % If there is no observed measurement bu filter thinks there
            % should be - just go along with and see what happens
            measDelta = computedMeas;
        else
            
            % measurements from all stations at time
            fullObsMeas = observedMeas;
            
            % range and range rate at time
            ObsMeasRange     = fullObsMeas(1:3);
            ObsMeasRangerate = fullObsMeas(4:6);
            
            measDelta = [ObsMeasRange(statNumOb(q)); ObsMeasRangerate(statNumOb(q))] - computedMeas;
        end
        
        % If measureemnt residuals isn't an outlier than process it
        if abs(measDelta(1)) < 1
        % Compute Htilde
        Htilde{i} = Measurements.HtildeSC(refTrajStates', stationECI{i,statNumOb(q)}, MeasFlag);
        
        % Kalman Gain
        Kk = pMinus*Htilde{i}' / (Htilde{i}*pMinus*Htilde{i}' + R);
        
        xhat = Kk * measDelta;
        
        % reference state + deviation
        Xplus = refTrajStates' + xhat;
        
        % covariance update
        Pplus = (eye(6,6) - Kk*Htilde{i}) * pMinus * (eye(6,6) - Kk*Htilde{i})' + Kk*R*Kk';
        
        assert(trace(Pplus) < trace(pMinus), 'Covariance not decrease!');
        
        end
        
        end
        
    else
        % no station made an observation - simply propagate state w/o meas
        Xplus = refTrajStates';
        Pplus = pMinus;
        measDelta = [NaN; NaN];
        
    end
    
    
    % save histories
    XrefHist(:,i) = Xplus;
    PplusHist{i} = Pplus; 
    measDeltaHist(:,i) = measDelta; 
    
    % reset everything for next iteration
    XrefPrev = [Xplus; reshape(eye(6,6), [36,1])];
    pPrev    = Pplus;
    timePrev = tVec(i);
    
end

end
